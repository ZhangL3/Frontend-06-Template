# 学习笔记 Week4

## 字符串分析算法

1. 字典树
大量高重复字符串的储存与分析。
2. KMP
在长字符串里找匹配。检查一个字符串是否是另一个字符串的一部分。能做到 m + n 的复杂度，而不是 m * n
3. Wildcard
带通配符的字符串模式。带 ？ 和 * 的 KMP
4. 正则
字符串通用模式匹配
5. 状态机
通用的字符串分析
6. LL，LR
字符串多层级结构分析

### 字典树 Trie

快速查找字符串出现的次数。就相当于查字典，字典会显示这个词被查了几次。

#### 思路

                    h
                 /     \ 
                e       i
               / \      |
              l   5     3
            /   \   
           l     p 
           |     |
           o     1
           |
           10

#### 数据结构

$ 是该字符串被查找的次数

```js
trie =
{
    h: {
        e: {
            l: {
                l: {
                    o: {
                        $: 10,
                    },
                },
                p: {
                    $: 1,
                },
            },
            $: 5,
        },
        i: {
            $: 3,
        },
    },
}
```

### KMP

找 source：string 里是否包含 pattern：string

例如：
source: 'aabaabaacx'
pattern:  'aabaac'

#### 思路

暴力解的情况就是一个一个字符相对应，发现有不同的地方就把 pattern 向后错一位，直到找到对应(true)或者找尽(false)。 其实也不用找尽，source.length - source[ i ] < pattern.length - pattern[ j ] 也是 false 了。
KMP 方法就是先看 pattern 里有没有重复的段落。如果有，并且和 source 匹配的时，不匹配的字符就出现在这个重复片段中，就不用挪一位，而是一次挪到匹配传递的位置，减少了循环的次数。

#### 详解

##### 暴力解法

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source | a | a | b | a | a | **b** | a | a | c | x |
|round 0| a | a | b | a | a | **c** | x |

index = 5 时， d != c。再开始找的时候， source 从 index = 1 开始，pattern 从头开始。其实就相当于 pattern 向后错一位, 让 pattern 的开头和 source 当前轮的开头对齐

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source | a | a | **b** | a | a | b | a | a | c | x |
|round 1|   | a | **a** | b | a | a | c | x |

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source | a | a | **b** | a | a | b | a | a | c | x |
|round 2|   |   | **a** | a | b | a | a | c | x |

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source | a | a | b | a | a | b | a | a | c | x |
|round 3|   |   |   | a | a | b | a | a | c | x |

匹配成功，source[3 : 9] 与 pattern 完全匹配

##### kmp解法

##### 第一步 找 pattern 中是不是有和开头儿重复的片段

|table        | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|-------------|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | c | x |
|pattern [ j ]| a | a | b | a | a | c | x |
|index        | 0 | 1 | 2 | 3 | 4 | 5 | 6 |

1. 初始时 i = 1， j = 0；
2. 如果 pattern[ i ] == patter[ j ], i++ 且 j++，并且把 j 的值写入 table[ i ]
3. 如果 pattern[ i ] != patter[ j ] && j == 0, 那就 i++，看 i 的那一排的下一位是不是和 pattern[ j ] 相同；
4. 如果前面匹配，后面又不匹配了, 即 pattern[ i ] != patter[ j ] && j > 0，那 j = table[ j ]，回溯到上一个匹配字符串的后缀
|table        | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | **a** | b | a | a | c | x |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|index        | **0** | 1 | 2 | 3 | 4 | 5 | 6 |

1. =>

|table        | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | **b** | a | a | c | x |
|pattern [ j ]| a | **a** | b | a | a | c | x |
|index        | 0 | **1** | 2 | 3 | 4 | 5 | 6 |

4. table [ 1 ] = 0 => j = 0

|table        | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | **a** | a | c | x |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|index        | **0** | 1 | 2 | 3 | 4 | 5 | 6 |

1. =>

|table        | 0 | 0 | 1 | 0 | 1 | 0 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | **a** | c | x |
|pattern [ j ]| a | **a** | b | a | a | c | x |
|index        | 0 | **1** | 2 | 3 | 4 | 5 | 6 |

1. =>

|table        | 0 | 0 | 1 | 0 | 1 | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | **c** | x |
|pattern [ j ]| a | a | **b** | a | a | c | x |
|index        | 0 | 1 | **2** | 3 | 4 | 5 | 6 |

4. table [ 2 ] = 1 => j = 1

|table        | 0 | 0 | 1 | 0 | 1 | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | **c** | x |
|pattern [ j ]| a | **a** | b | a | a | c | x |
|index        | 0 | **1** | 2 | 3 | 4 | 5 | 6 |

4. table [ 1 ] = 0 => j = 0

|table        | 0 | 0 | 1 | 0 | 1 | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | **c** | x |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|index        | **0** | 1 | 2 | 3 | 4 | 5 | 6 |

3. i++ =>

|table        | 0 | 0 | 1 | 0 | 1 | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | **c** | x |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|index        | **0** | 1 | 2 | 3 | 4 | 5 | 6 |

3. =>

|table        | 0 | 0 | 1 | 0 | 1 | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | a | b | a | a | c | **x** |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|index        | **0** | 1 | 2 | 3 | 4 | 5 | 6 |

***匹配结束时，重复的段落的 table 值，就是从头开始的 index 值。重复段落结束的第一个 table值，就是匹配到的长度***

|table        | 0 | ***0*** | 1 | ***0*** | ***1*** | 2 | 0 |
|-------------|---|---|---|---|---|---|---|---|
|pattern [ i ]| a | ***a*** | b | ***a*** | ***a*** | c | x |
|pattern [ j ]| ***a*** | ***a*** | b | a | a | c | x |
|index        | ***0*** | ***1*** | 2 | 3 | 4 | 5 | 6 |

##### 第二步 匹配 pattern 和 source

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source [ i ] | a | a | b | a | a | b | a | a | c | x |
|pattern [ j ]| a | a | b | a | a | c | x |
|table [ j ] | 0 | 0 | 1 | 0 | 1 | 2 | 0 |

1. 初始时 i = 0， j = 0；
2. 如果 source[ i ] == patter[ j ], i++ 且 j++
3. 如果 source[ i ] != patter[ j ] && j == 0, 那就 i++，看 source[ i ] 的下一位是不是和 pattern[ j ] 相同；
4. 如果前面匹配，后面又不匹配了, 即 pattern[ i ] != pattern[ j ] && j > 0，那 j = table[ j ]

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source [ i ] | **a** | a | b | a | a | b | a | a | c | x |
|pattern [ j ]| **a** | a | b | a | a | c | x |
|table [ j ] | **0** | 0 | 1 | 0 | 1 | 2 | 0 |

1. => 1. => 1. => 1. =>

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source [ i ] | a | a | b | a | a | **b** | a | a | c | x |
|pattern [ j ]| a | a | b | a | a | **c** | x |
|table [ j ] | 0 | 0 | 1 | 0 | 1 | **2** | 0 |

4. table[ 5 ] = 2; j = 2; pattern 到 c 的时候，通过 table 可以知道，c 前面的两位和 pattern 开头的两位相同，所以再调整指针的时候不用调到头，只调到相同匹配后面的一位就好了 =>

这就相当于 source[ 3 : 4 ] == pattern[ 3 : 4 ] => source[ 3 : 4 ] == pattern[ 0 : 1 ], 因为 pattern[ 3 : 4 ] == pattern[ 0 : 1 ]

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source [ i ] | a | a | b | a | a | **b** | a | a | c | x |
|pattern [ j ]| *a* | *a* | **b** | *a* | *a* | c | x |
|table [ j ] | *0* | *0* | **1** | 0 | 1 | 2 | 0 |

按暴力解理解的话，就是 pattern[ 0 : 1 ] 和 source[ 3 : 4 ] 对齐

|index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|------ |---|---|---|---|---|---|---|---|---|---|
|source [ i ] | a | a | b | a | a | **b** | a | a | c | x |
|pattern [ j ]|   |   |   | a | a | **b** | a | a | c | x |
|table [ j ]  |   |   |   | 0 | 0 | **1** | 0 | 1 | 2 | 0 |

### Wildcard

检查 source 是否符合带通配符的 pattern

例如:
source: 'abcabcabxaac'
pattern: 'a*b*bx*c'

Wildcard 的关键是多了两个通配符 \* 和 ?。? 的处理过于复杂，代码就用正则以处理。 \* 的处理是重点。这种处理能平衡代码运行效率和编程效率

#### 思路

因为要用到的匹配的算法不同，匹配要分为两段，其中第二段有又分为两段：

1. 第一个 \* 之前的字符：没有 *，只要从前到后一个一个匹配就好了，遇到 ? 就通过
2. 第一个 \* 到最后一个 \* ：\* 是否匹配的关键是 \* 和它后面紧邻的字符
2.1 最后一个 \* 之前的所有 \*: 因为 \* 后面紧邻的只有字符，所以 \* 是匹配尽量少的字符
2.2 最后一个 \*: 和最后一个 \* 紧邻的是字符 + 结束符，所有最后一个 \* 匹配的是尽量多的字符
